---
title: Мобильная система мониторинга
repository: mobile-monitoring-system
preview: ./assets/images/projects/mobile-monitoring-system/preview.png
excerpt: Идентификация датчиков во время совершения обхода, получение информации с Центрального поста о значениях их показаний, визуализация показаний с датчика на экране мобильного устройства, отправка сообщения на Центральный пост о том, что объект был осмотрен...
date: 27-06-2019
categories: ru projects
tags: [studies, java, android, mqtt]
date: 27.06.2019
layout: project
lang: Ru

QR-codes:
  - path: ./assets/images/projects/mobile-monitoring-system/ru_Company_Engine-room_oil-pressure.gif
    title: Рис.5. Давление масла
  - path: ./assets/images/projects/mobile-monitoring-system/ru_Company_Engine-room_revs.gif
    title: Рис.6. Количество оборотов
  - path: ./assets/images/projects/mobile-monitoring-system/ru_Company_Foundry-Shop_temperature.gif
    title: Рис.7. Температура
  - path: ./assets/images/projects/mobile-monitoring-system/ru_Company_Assembly-line_speed.gif
    title: Рис.8. Скорость конвейера
---

## 1. Цель проекта

Создание программной системы для автоматизации контроля за проведением обходов на предприятиях, повышения качества их осуществления, освобождение персонала от рутинных операций по заполнению журналов обхода, с помощью идентификации датчиков во время совершения обхода, получения информации с Центрального поста о значениях их показаний, визуализации показаний с датчика на экране мобильного устройства, отправки сообщения на Центральный пост о том, что объект был осмотрен.

### 1.2. Область применения разработки
Приложение предназначено для работы на предприятиях с системой централизованного получения технологической информации с объектов её инфраструктуры.

## 2. Функциональные требования

* Реализация идентификации датчиков при совершении обхода;
* Реализация подключения к серверу с данными о показаниях датчиков;
* Организация автоматического получения данных о показаниях идентифицированных датчиков;
* Сохранение информации, полученной с датчиков, в памяти устройства;
* Отображение информации полученной с датчиков в виде списка датчиков и значений их показаний.
* Предоставление пользователю возможность выборочного удаления записей или полную очистку приложения от данных с датчиков.
* Реализация автоматической отправки данных о совершении обхода, для поддержания трудовой дисциплины.
* Реализация интуитивно понятного пользовательского интерфейса. В интерфейсе должны быть реализованы следующие возможности:
    * Аутентификация;
    * Настройка подключения к серверу;
    * Идентификация датчиков;
    * Визуализация сохранённых показаний;

### 2.1. Входныe данныe
* Адрес сервера в сети(для настройки подключения);
* Имя пользователя и пароль(для входа в систему);
* Имя датчика, представленное в удобном для быстрого ввода виде(для получения показаний датчика);

### 2.2. Входныe данныe
* Показания датчика на экране мобильного устройства.

### 2.3. Идентификация датчиков в системе
Так как датчиков может быть огромное множество, а их типы и назначение повторятся, целесообразно их структурировать в виде каталогов. Имена вложенных каталогов указывать через «слеш» ( / ), последним будет указано название датчика, например: 
`Название_системы / название_подсистемы / имя_датчика` - это будет полное имя датчика. Полное имя датчика будет использоваться для получения информации с него. 
Для того чтобы быстро и точно передать имя датчика в приложение можно использовать Bluetooth-маяки и NFC-метки, закодировав его в соответствующий сигнал.

В рамках дипломной работы я заменил эти два способа передачи данных считыванием QR-кодов. Данная функция работает аналогично, только используется не чип NFC или Bluetooth модуль, а камера смартфона. Это делает систему ещё более доступной, так как не нужно использовать дополнительное оборудование кроме принтера. Вместе с тем она имеет один существенный недостаток: недобросовестный обходчик может скопировать изображение и никуда не ходить.

### 2.4. Требования к аппаратному и программному обеспечению
Мобильный телефон – смартфон с поддержкой передачи данных сети Wi-fi, Bluetooth, NFC, оснащённый цифровой камерой, под управлением операционной системы Android 8.1 и выше.

### 2.5. Сетевой протокол для передачи данных на устройство
Для взаимодействия между собой устройства используют различные промышленные протоколы, одним из популярных протоколов для этой цели является MQTT.
MQTT или Message Queue Telemetry Transport – это легкий, компактный и открытый протокол обмена данными созданный для передачи данных на удалённых локациях, где требуется небольшой размер кода и есть ограничения по пропускной способности канала. Вышеперечисленные достоинства позволяют применять его в системах M2M (Машинно-Машинное взаимодействие) и IIoT (Промышленный Интернет вещей).

## 3. Реализация

Исходя из анализа требований, предъявляемых к системе, была составлена её структурная схема:

![Рис.1. Структурная схема](/assets/images/projects/mobile-monitoring-system/structural-diagram.png "Рис.1. Структурная схема")

### 3.1. Алгоритм работы приложения
В работе приложения можно выделить четыре основных этапа:
* Аутентификация и настройка
* Взаимодействие с сервером
* Детектирование QR-кодов
* Работа с базой данных

Все этапы представлены в алгоритме:

![Рис.2. Алгоритм](/assets/images/projects/mobile-monitoring-system/block-diagram_ru.gif "Рис.1. Алгоритм")

### 3.2. Структура приложения

Название модуля     | Реализуемая функция
--------------------|-----------------------
MQTT                | Подключение к брокеру, аутентификация передачу сообщений с докладом о идентификации датчика, получение сообщений с показаниями идентифицированных датчиков
QRDecoder.Camera    | Управление камерой и получение изображения с неё
QRDecoder.Barcode   | Детектирование и расшифровывание QR-кодов, полученных в виде изображений с камеры
Database            | Взаимодействие с базой данных SQLite
UI                  | Реализация пользовательского интерфейса

![Рис.3. Диаграмма классов](/assets/images/projects/mobile-monitoring-system/class-diagram.jpg "Рис.3. Диаграмма классов")

### 3.3. **MQTT**-клиент
**MQTT** или **Message Queue Telemetry Transport** – это легкий, компактный и открытый протокол обмена данными созданный для передачи данных на удалённых локациях, где требуется небольшой размер кода и есть ограничения по пропускной способности канала. Вышеперечисленные достоинства позволяют применять его в системах **M2M** (Машинно-Машинное взаимодействие) и **IIoT** (Промышленный Интернет вещей).

Для создания **MQTT**-клиента в своём приложении я использовал **Paho MQTT** и **Android**-сервис, предоставляемый Eclipse. 
Как добавить его в проект и как с ним взаимодействовать прсмотренно в статье [MQTT-клиент для Androud]({{site.url}}/ru/cases/mqtt-client).

### 3.4. Идентификация датчиков
Идентификатором датчика в системе будет уникальное имя датчика, ввод которого будет осуществлён с помощью камеры устройства.
Для обработки изображений, специалистами _Google_ были реализованы примеры кода **[android-vision](https://github.com/googlesamples/android-vision)**, в которых присутствует модуль **barcode-reader**, состоящий из классов:

Название класса         | Реализуемая функция
------------------------|-----------------------
CameraSource            | Предоставляет управление камерой для получения предварительного просмотра. Получает изображение предварительного просмотра камеры с определённой частотой, отправляя кадры детектору по мере того как он их обрабатывать. Кадры могут быть отброшены, если детектор не успевает обрабатывать все кадры, генерируемые камерой. Частоту кадров можно указать с помощью метода setRequestedFps (float).
CameraSourcePreview     | Отвечает за отображение кадров предварительного просмотра камеры на экран.
GraphicOverlay          | Отображает графические объекты поверх связанного предварительного просмотра камеры. Представление, отображающее серию пользовательских графических объектов, накладываемых поверх связанного предварительного просмотра (т. е. камеры). Позволяет добавлять графические объекты, обновлять их и удалять их, вызывая и отключая видимость соответствующего рисунка в пределах view. Поддерживает масштабирование и зеркальное отображение графики относительно свойств предварительного просмотра камеры. Размеры элементов выражаются в значениях размера предварительного просмотра, но должны быть масштабированы к полному размеру экрана.
BarcodeGraphicTracker   | Это трекер, который используется для обнаружения штрихкодов на экране, и их отслеживания для наложения графики, а также удаления графики, когда штрих-код покидает зону видимости.
BarcodeGraphic          | Используется для отрисовки экземпляра накладываемого на штрих-код изображения с учетом его положения, размера и идентификатора.
BarcodeTrackerFactory   | Реализует паттерн «Фабрика» и используется для создания трекеров штрих-кода — по одному для каждого штрих-кода.

Эти классы используют интерфейсы **Mobile Vision**, которые обеспечивают API для обнаружения штрих-кода. На данный момент эта библиотека уже устарела и не поддерживается, вместо неё можно воспользоваться библиотекой **[ML Kit](https://developers.google.com/ml-kit)**

### 3.5. Хранение информации
Информацию сохраняемая в приложении делится на два группы:
* Параметры камеры(подсветка, автофокусировка) и настройки соединения
* Показания датчиков

Первая группа характеризуется небольшим, но постоянным объёмом данных. Поэтому для неё в качестве хранилища будет использован  SharedPreferences — постоянное хранилище на платформе Android, используемое приложениями для хранения своих настроек. В файле SharedPreferences будут созданы поля вида: 
```xml
<map>
    <string name="Ключ">Значение</string>
</map>
```

Ключи и значения параметров будут задаваться при старте приложения и хранится в закрытом хранилище. Планируется использовать следующие ключи:
* _autoFocus_ — отвечает за использование автофокусировки, принимает значения: 

    **ON** — автофокусировка активирована

    **OFF** — автофокусировка деактивирована

* _useFlash_ — отвечает за включение / выключение подсветки камеры, принимает значения: 

    **ON** — подсветка камеры включена

    **OFF** — подсветка камеры выключена

* _url_address_ — соответствует значению url-адреса сервера; 
* _port_number_ — соответствует значению номера порта;

Вторая группа — показания датчиков — очень динамична в процессе работы и может как увеличивать объём данных, используемых в приложении, так и уменьшать. Для хранения информации о показаниях датчиков приложение использует базу данных SQLite.

База данных приложения будет состоять из трёх таблиц:
* _types_ — содержит основные типы датчиков
* _sensors_ — содержит уникальные имена датчиков
* _readings_ — хранит показания датчиков

![Рис.4. База данных приложения](/assets/images/projects/mobile-monitoring-system/application-database.png "Рис.4. База данных приложения")

В таблице types, кроме поля id, которое является первичным ключом, присутствуют ещё четыре поля:
* _type_neme_ — текстовое поле с названием типа датчиков
* _unit_of_measure_ — текстовое поле с названием единиц измерения
* _upper_limit_ — информация о верхней границеизмерений, тип real
* _lover_limit_ — информация о нижней границеизмерений, тип real

В таблице sensors, помимо поля id, которое является первичным ключом, имеются три поля:
* _sensor_name_ — текстовое поле с именем датчика
* _unit_of_measure_ — foreign key, соответствующий id из таблицы types требуется для сопоставления датчика и единиц измерения соответствующих данному типу датчика. 
* _detection_time_ — время обнаружения и распознавания датчика, необходимо для сортировки данных при выводе в виде INT(long).

В третей таблице readings также присутствует поле id(первичный ключи),  и три поля:
* _sensor_ — foreign key, соответствующий id из таблицы sensors,
* _value_ — хранит значение полученное от сервера
* _time_ — содержит значение времени с последнего обновления значения.

### 3.6. Графический интерфейс пользователя
Непосредственного взаимодействия пользователя ожидают четыре функции: аутентификация, настройка подключения к серверу, идентификация датчиков и визуализация их показаний. На основании этого была составлена навигационная карта приложения:

![Рис.5. Навигационная карта](/assets/images/projects/mobile-monitoring-system/navigation-map.png "Рис.5. Навигационная карта")

Экран аутентификации содержит текстовые поля для ввода имени пользователя и пароля, которые используются для аутентификации пользователя в системе, Кнопку _«Sign in»_, при нажатии которой происходит попытка соединиться с сервером, виртуальную клавиатуру для ввода значений в текстовые поля. Также в верхнем меню присутствует кнопка перехода, к экрану настроек оформленная в виде значка шестерёнки.

Если после нажатия на кнопку _«Sign in»_ соединение с сервером не будет установлено, на экран будет выведено сообщение об ошибке с предложением проверить настройки соединения. Для настройки соединения необходимо нажать на знак в виде шестерёнки в углу экрана. Произойдёт переход на экран настройки.

На экране настройки также присутствуют два текстовых поля:
* Поле для ввода URL — адреса.
* Поле для ввода номера порта.

Виртуальная клавиатура зависит от активного текстового поля. Если активно поле URL — адреса, выводится полноценная клавиатура с основными буквенное-символьными элементами. Если активно поле для ввода номера порта — выводится только цифровая  клавиатура.
В верхнем меню активируются следующие пункты
* _«Back arrow»_ — осуществляет возврат на предыдущий экран.
* _«Lighting»_ — активирует подсветку с помощью камеры (если такой поддерживается устройством).
* _«Autofocus»_ — активирует режим автофокусировки камеры (если такой поддерживается устройством).
* _«Save»_ — сохраняет введённые настройки.

Основной экран приложения объединяет область для идентификации датчика и список.
Для идентификации датчика используется изображение с камеры, которую пользователь направляет на _QR-код_.  Ниже отображается список идентифицированных датчиков в порядке обратном времени идентификации. Каждый элемент списка содержит название датчика и его показания.

Внизу экрана расположено горизонтальное меню, которое состоит из пунктов:
* _«Relogin»_ - переход на экран аутентификации;
* _«Settings»_ - переход на экран настроек;
* _«Clear all»_ - удаление всех записей и отключение запросов.

Кроме того специальные движения позволяют регулировать zoom на камере, а продолжительное нажатие на элемент списка вызывает контекстное меню, через которое можно удалить данный элемент.

## 4. Тестирование

Для проверки работоспособности приложения потребуется:
* Компьютер с возможностью подключения к сети и сетевой ОС;
* Маршрутизатор WiFi;
* MQTT - брокер;
* Скрипт для моделирования генерации показаний датчиков;
* QR-коды с зашифрованными в них именами датчиков.

### 4.1. Установка MQTT-сервера
Для организации передачи сообщений по сети необходимо установить _Mosquitto_ – это популярный **MQTT**-сервер (или брокер). Он прост в установке и настройке и активно поддерживается сообществом разработчиков.
Устанавливаем _Mosquitto_ с помощью консольной команды:

    sudo apt-get install mosquitto-clients

По умолчанию сервис _Mosquitto_ запускается сразу после установки. 
Для настройки пароля в консоль вводим:

    sudo mosquitto_passwd -c /etc/mosquitto/passwd <username>

Открываем файл конфигурации:

    sudo nano /etc/mosquitto/mosquitto.conf

В открывшемся файле необходимо указать путь к файлу с именем пользователя и хэшем пароля:

    allow_anonymous false
    password_file /etc/mosquitto/mosquitto.pwd

После сохранения файла, нужно перезапустить сервер:

    sudo systemctl restart mosquitto

### 4.2. Скрипт для генерации тестовых значений
Для моделирования работы системы был написан скрипт на языке **bash**. В бесконечном цикле скрипт генерирует случайные значения и посредством команды `mosquitto_pub` отправляет их на сервер, который перенаправляет эти сообщения клиентам, подписавшимся на соответствующие темы.
```bash
#!/bin/bash
echo "Рестарт сервера"
sudo systemctl stop mosquitto
sleep 0.5
sudo systemctl start mosquitto
sleep 0.5

echo "Получим адрес сервера"
ipm="$(ip -4 addr show scope global | awk '$1 ~ /^inet/ {print $2}')"
ip="$(echo $ipm | awk -F"/"'{print $1}')"
echo "ip = "$ip

echo "Запускаем цикл генерации значений"
echo "---------------------------------"
n=32
i=0

while [ 1 ]
do
    let "number = ($RANDOM % 100)"
    number=0.7$number
    number+="Bar"
    mosquitto_pub -h $ip -t "ОНП/Маш.Зал/давление масла" -m $number -u "8host" -P "1234"

    let "number = ($RANDOM % 10 + 1495)"
    number+="об/c"
    mosquitto_pub -h $ip -t "ОНП/Маш.Зал/обороты" -m $number -u "8host" -P "1234"

    let "number = ($RANDOM % 10)"
    number=34.3$number
    number+="С"
    mosquitto_pub -h $ip -t "ОНП/Литейный цех/температура" -m $number -u "8host" -P "1234"

    let "number = ($RANDOM % 10)"
    number=2.5$number\
    number+="м/с"
    mosquitto_pub -h $ip -t "ОНП/Сборочный конвейер/скорость" -m $number -u "8host" -P "1234"
done
```

### 4.3. QR-коды
Для проверки работоспособности были сгенерированы соответствующие QR-коды:
{% include image-gallery.html collection = page.QR-codes number = "four" %}

_Спасибо за внимание! :)_
